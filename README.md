# 漫画算法
## 概念：
>数据结构：是数据的组织、管理和存储格式，期使用目睹是为了高效地访问和修改数据。

1. 线性数据结构：最简单的数据结构，包括数组、链表，以及由它们衍射出来的栈、队列、哈希表

2. 树：相对复杂的数据结构，比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构

3. 图：更为复杂的数据结构，因为在图中会呈现出多对多的关联关系

4. 其他数据结构：用于解决某些特定问题，基本由基础数据结构变形而来，如跳表、哈希链表、位图等。
#
>时间复杂度

+ 原则：
      
      1. 如果时间运行时间是常数量级，则用常数1表示
      
      2. 只保留时间函数中的最高阶项
      
      3. 如果最高阶项存在，则省去最高阶项前面的系数

+ 案例：
      
      1.  T(n)=3n  =>  T(n)=O(n)
      
      2.  T(n)=5logn  =>  T(n)=O(logn)
      
      3.  T(n)=2  => T(n)=O(1)
      
      4.  T(n)=0.5n^2+0.5n => T(n)=O(n^2)
      
+ 补充：
      
      O(1)<O(logn)<O(n)<O(n^2)
      
      还有许多不同的时间复杂度，如：O(n!)、O(nlogn)、O(2^n)、O(mn)、O(n^3)……

#  
>空间复杂度：是一个算法在运行中临时占用存储空间大小的量度，它同样使用了大O表示法

    1. 常量空间：当算法的存储空间大小固定，和输入规模没有直接关系时，空间复杂度记作O(1)

    2. 线性空间：当算法分配的空间是一个线性的结合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)

    3. 二维空间：当算法分配的空间是一个二维数组集合，别切集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2)

    4. 递归空间：复杂度O(n)

#
## 数组
>数组中的每一个元素，都存储在小小的内存单元中，别切元素之间紧密排列，既不能打乱元素存储顺序，也不能跳过某个存储单元进行存储

    1. 数组的读取和更新元素的时间复杂度都是O(1)
    
    2. 数组的扩容：创建一个新的数组，长度是新数组的2倍，再把旧数组的元素统统复制进去，这样就实现了数组的扩容。
    
    3. 数组的扩、插入、删除的时间复杂度都是O(n)
    
    4. 投机方式：当前提数组的顺序没有要求的时候，可以做最后一个元素复制到删除元素的位置上
                 
    5. 数组的优势：可以使用常量时间就找到对应元素。   
    
    6. 数组的劣势：由于数组元素联系紧密地存储在内存中，插入、删除元素都会导致大量的元素被迫移动，影响效率。

#
## 链表
>链表是一种物理结构上非连续、非顺序的数据结构，由若干节点所组成。
    
    1. 若想回溯到他的上个前置节点，我们可以使用双向链表
    
    2. 链表在内存中的存储方式是随机存储的
    
    3. 不考虑插入、删除操作之前查找元素的过程，插入和删除操作时间复杂度都是O(1)
    
#
## 栈和队列
>物理结构：
>>数序结构：数组

>>链式结构：链表

>逻辑结构：
>>线性结构： 顺序表、栈、队列

>>非线性结构：树、图

>栈是在一中线性结构，先入后出（First In Last Out，FILO）。最早进入的元素存放的位置叫栈底，最后进入的元素叫栈顶。

    1. 这种数据结构可以用数组和链表表示
    
    2. 无论是链表还是数组入栈和出栈的时间复杂度都是O(1)

>队列是一种线性结构，队列的元素只能先入先出（First In First Out，FIFO）队列的出口端点叫做队头，入口端点叫做队尾。
    
    1.  循环队列： 在物理存储上，队尾的位置也可以在队头之前。党再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。
    
    2、入队和出队的时间队列都是O(1)
    
    3. 双端队列： 队头一端可以入队或出队，从队尾一端剋入队或出队
    
    4. 优先队列： 谁的优先级高谁先出队

>散列表：也叫哈希表，这种数据结构提供了键和值的映射关系，时间复杂度接近O(1)

    1. 解决哈希冲突的两种方法：开放寻址法和链表法
        1） 开放寻址法：就是寻找下一个空挡位置。
        2） 链表法：在原位置的节点上指向下个元素
    
    2. 扩容，创建一个新的Entry空数组，长度原来数组的2倍
    
    3. 重新Hash，遍历员Entry数组，把所有的Entry重新Hash到新数组中去。

#
## 树

>二叉树
>>每个节点最多只有2个孩子节点。
    
    1. 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，兵器所有叶子节点都在同一层级上，那么这个树就是满二叉树
    
    2. 完全二叉树：如果一个二叉树和深度相同的满二叉树的编号和位置相同。
    
>>二叉树的表达方式
    
    1. 链式存储：
       1）存储数据的 data变量
       2）指向做孩子的left指针
       3）指向右孩子的right指针
    
    2. 数组存储的结构
       假设一个父节点的下标时parent，那么它的左孩子节点下标就是2*parent+1;有孩子的节点下标就是2*parent+2，
       显然队一个稀疏的二叉树来说，用数组表示法时浪费空间的。但是二叉堆时是一种特殊的完全二叉树，就是用数组来存储的                                                             
                                                                                                        
    3. 二叉查找树(二叉排序树)
       1）如果左子树不为空，则左子树上所有节点的值均小于根节点的值
       2）如果右子s树不为空，则右子树上送油节点的值均大于根节点的值
       3）左、右也都是时二叉查找树
       4）二叉查找树的时间复杂度时O(logn)

>>二叉树的遍历

    1. 深度优先遍历
      1）前序遍历：根节点->左子树->右子树
      
      2）中序遍历：左子树、根节点、右子树
      
      3）后序遍历：左子树、右子树、根节点
    
    绝大多数可以用赌鬼解决的问题，其实都可以用栈来解决，因为递归和栈都有回溯性。

    2. 广度优先遍历
       层序遍历： 就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历各个节点，可以使用队列来实现

#
## 二叉堆
>最大堆：任何一个父节点的值，都大于或等于它左右孩子节点的值

>最小堆：任何一个父节点的值，都小于或等于它左右孩子节点的值

二叉堆的根节点叫做堆顶

> 二叉堆的自我调整
    
    1. 插入节点：插入的位置时二叉树的最后一个位置，然后进行上浮操作
    
    2. 删除节点： 将堆的最后一个即诶带你临时补到删除节点的位置，然后进行下沉操作
    
    3. 构建二叉堆： 就是把一个无序的完全二叉树调整为二叉堆，本质让所欧非叶子节点依次“下沉”。从最后一个非叶子节点开始下沉
   
    4. 插入、删除的时间复杂度时O(logn), 构建是O(n)
    

    
    