# 漫画算法
## 概念：
>数据结构：是数据的组织、管理和存储格式，期使用目睹是为了高效地访问和修改数据。

1. 线性数据结构：最简单的数据结构，包括数组、链表，以及由它们衍射出来的栈、队列、哈希表

2. 树：相对复杂的数据结构，比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构

3. 图：更为复杂的数据结构，因为在图中会呈现出多对多的关联关系

4. 其他数据结构：用于解决某些特定问题，基本由基础数据结构变形而来，如跳表、哈希链表、位图等。
#
>时间复杂度

+ 原则：
      
      1. 如果时间运行时间是常数量级，则用常数1表示
      
      2. 只保留时间函数中的最高阶项
      
      3. 如果最高阶项存在，则省去最高阶项前面的系数

+ 案例：
      
      1.  T(n)=3n  =>  T(n)=O(n)
      
      2.  T(n)=5logn  =>  T(n)=O(logn)
      
      3.  T(n)=2  => T(n)=O(1)
      
      4.  T(n)=0.5n^2+0.5n => T(n)=O(n^2)
      
+ 补充：
      
      O(1)<O(logn)<O(n)<O(n^2)
      
      还有许多不同的时间复杂度，如：O(n!)、O(nlogn)、O(2^n)、O(mn)、O(n^3)……

#  
>空间复杂度：是一个算法在运行中临时占用存储空间大小的量度，它同样使用了大O表示法

    1. 常量空间：当算法的存储空间大小固定，和输入规模没有直接关系时，空间复杂度记作O(1)

    2. 线性空间：当算法分配的空间是一个线性的结合（如数组），并且集合大小和输入规模n成正比时，空间复杂度记作O(n)

    3. 二维空间：当算法分配的空间是一个二维数组集合，别切集合的长度和宽度都与输入规模n成正比时，空间复杂度记作O(n^2)

    4. 递归空间：复杂度O(n)

#
## 数组
>数组中的每一个元素，都存储在小小的内存单元中，别切元素之间紧密排列，既不能打乱元素存储顺序，也不能跳过某个存储单元进行存储

    1. 数组的读取和更新元素的时间复杂度都是O(1)
    
    2. 数组的扩容：创建一个新的数组，长度是新数组的2倍，再把旧数组的元素统统复制进去，这样就实现了数组的扩容。
    
    3. 数组的扩、插入、删除的时间复杂度都是O(n)
    
    4. 投机方式：当前提数组的顺序没有要求的时候，可以做最后一个元素复制到删除元素的位置上
                 
    5. 数组的优势：可以使用常量时间就找到对应元素。   
    
    6. 数组的劣势：由于数组元素联系紧密地存储在内存中，插入、删除元素都会导致大量的元素被迫移动，影响效率。

#
## 链表
>链表是一种物理结构上非连续、非顺序的数据结构，由若干节点所组成。
    
    1. 若想回溯到他的上个前置节点，我们可以使用双向链表
    
    2. 链表在内存中的存储方式是随机存储的
    
    3. 不考虑插入、删除操作之前查找元素的过程，插入和删除操作时间复杂度都是O(1)
    
#
## 栈和队列
>物理结构：
>>数序结构：数组

>>链式结构：链表

>逻辑结构：
>>线性结构： 顺序表、栈、队列

>>非线性结构：树、图

>栈是在一中线性结构，先入后出（First In Last Out，FILO）。最早进入的元素存放的位置叫栈底，最后进入的元素叫栈顶。

    1. 这种数据结构可以用数组和链表表示
    
    2. 无论是链表还是数组入栈和出栈的时间复杂度都是O(1)

>队列是一种线性结构，队列的元素只能先入先出（First In First Out，FIFO）队列的出口端点叫做队头，入口端点叫做队尾。
    
    1.  循环队列： 在物理存储上，队尾的位置也可以在队头之前。党再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。
    
    2、入队和出队的时间队列都是O(1)
    
    3. 双端队列： 队头一端可以入队或出队，从队尾一端剋入队或出队
    
    4. 优先队列： 谁的优先级高谁先出队

>散列表：也叫哈希表，这种数据结构提供了键和值的映射关系，时间复杂度接近O(1)

    1. 解决哈希冲突的两种方法：开放寻址法和链表法
        1） 开放寻址法：就是寻找下一个空挡位置。
        2） 链表法：在原位置的节点上指向下个元素
    
    2. 扩容，创建一个新的Entry空数组，长度原来数组的2倍
    
    3. 重新Hash，遍历员Entry数组，把所有的Entry重新Hash到新数组中去。

#
## 树

>二叉树
>>每个节点最多只有2个孩子节点。
    
    1. 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，兵器所有叶子节点都在同一层级上，那么这个树就是满二叉树
    
    2. 完全二叉树：如果一个二叉树和深度相同的满二叉树的编号和位置相同。
    
>>二叉树的表达方式
    
    1. 链式存储：
       1）存储数据的 data变量
       2）指向做孩子的left指针
       3）指向右孩子的right指针
    
    2. 数组存储的结构
       假设一个父节点的下标时parent，那么它的左孩子节点下标就是2*parent+1;有孩子的节点下标就是2*parent+2，
       显然队一个稀疏的二叉树来说，用数组表示法时浪费空间的。但是二叉堆时是一种特殊的完全二叉树，就是用数组来存储的                                                             
                                                                                                        
    3. 二叉查找树(二叉排序树)
       1）如果左子树不为空，则左子树上所有节点的值均小于根节点的值
       2）如果右子s树不为空，则右子树上送油节点的值均大于根节点的值
       3）左、右也都是时二叉查找树
       4）二叉查找树的时间复杂度时O(logn)

>>二叉树的遍历

    1. 深度优先遍历
      1）前序遍历：根节点->左子树->右子树
      
      2）中序遍历：左子树、根节点、右子树
      
      3）后序遍历：左子树、右子树、根节点
    
    绝大多数可以用赌鬼解决的问题，其实都可以用栈来解决，因为递归和栈都有回溯性。

    2. 广度优先遍历
       层序遍历： 就是按照二叉树从根节点到叶子节点的层次关系，一层一层横向遍历各个节点，可以使用队列来实现

#
## 二叉堆
>最大堆：任何一个父节点的值，都大于或等于它左右孩子节点的值

>最小堆：任何一个父节点的值，都小于或等于它左右孩子节点的值

二叉堆的根节点叫做堆顶

> 二叉堆的自我调整
    
    1. 插入节点：插入的位置时二叉树的最后一个位置，然后进行上浮操作
    
    2. 删除节点： 将堆的最后一个即诶带你临时补到删除节点的位置，然后进行下沉操作
    
    3. 构建二叉堆： 就是把一个无序的完全二叉树调整为二叉堆，本质让所欧非叶子节点依次“下沉”。从最后一个非叶子节点开始下沉
   
    4. 插入、删除的时间复杂度时O(logn), 构建是O(n)
    
#
## 优先队列
    1. 最大优先队列；无论入队数序如何，都是最大元素优先出队，最小有效队列则相反
    
    2. 可以使用最大堆实现最大优先队列，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶操作
    
    3. 入队和出队的时间复杂度都是O(logn)

>如果相同的元素在排序后仍保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序

#
## 冒泡排序
>把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。

>鸡尾酒排序： 大部分元素已经有序的情况使用，缺点：代码几乎增加一倍。

#
## 快速排序
>在每一轮挑选一个基准元素，并让其他比它大的玄素移动到数列的一边，比它小的元素移动到数列的另一边，从而把数列分解成两个部分。
    
>>每一轮比较和交换，需要把数组全部元素遍历一遍，时间复杂度时O(n)。这样的遍历需要logn轮，因此快速排序整体时间复杂度时O(nlogn)

>>选取基准元素：一般原则一个元素作为基准元素，并且让基准元素和队列首元素交换。
    
>元素的交换
>>双边循环法

    1. 选定基准与阿奴pivot，并设置两个指针left和rigt，指向数列的最左和最右两个元素
    
    2. 进行第一次循环，从right开始，让指针指向的元素和基准元素作比较，如果大于或等于pivote，
       则指针向左移动；如果小于pivot，则right只在乎你停止移动，切换到left指针。
       
    3. left指针移动，让指针所指向的元素和基准元素做比较。如果小于或等于piovt，则指针向右移动；
       如果大于piovt，则left指针停止移动。
    
    4. 最后让left和right指针所指向的元素进行交换。然后，进入第二次循环。
  
>>单边循环算法
    
    1. 首先选顶基准元素pivot，同时设置一个mark指针指向数列的其实位置，这个mark指针代表小于基准元素的区域边界。
    
    2. 遍历数组，如果遍历到的元素大于基准元素，就继续遍历；如果遇到元素小于基准元素:
       1) 将mark指针右移一位，因为小于pivot的区域边界增大了1；
       2）让最新遍历到的元素和mark指针所在诶之的元素交换位置，因为最新遍历的元素归属于小于pivot的区域
 
 #
 ## 堆排序
> 删除一个最大的堆顶（并不是完全删除，而是跟末尾节点交换位置），经过自我调整，第2大的玄素就会倍交换上来，成为最大堆的新堆顶。
>> 把无序数组构建成二叉堆，需要从小到大，则构建成最大堆；需要从大到小排序，则构建成最小堆。
 
>> 循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。

>> 堆排序算法的时间复杂度是O(logn),
>>> 将无序数组构建成二叉堆的时间复杂度是O(n)

>>> 需要进行n-1次循，每次循环需要调用一次downAdjust方法,所以第二次的计算规模是(n-1)*logn,时间浮渣度为O(nlogn)

>>> 两个步骤是并列关系，所以整体的时间复杂度是O(nlogn)

> 堆排序和快速排序的平均复杂度都是O(nlogn),并且都是不稳定排序。不同点再于，快速排序的最坏时间复杂度是O(n^2),而
  堆排序的时间复杂度稳定再O(nlogn)。此外，快速排序递归和非递归方法的平均空间复杂度都是O(logn),而堆排序的空间复杂度是O(1)
    
    